/*******************************************************************************/
/*  © Université de Lille, The Pip Development Team (2015-2025)                */
/*  Copyright (C) 2020-2025 Orange                                             */
/*                                                                             */
/*  This software is a computer program whose purpose is to run a filesystem   */
/*  with in-place execution and memory isolation.                              */
/*                                                                             */
/*  This software is governed by the CeCILL license under French law and       */
/*  abiding by the rules of distribution of free software.  You can  use,      */
/*  modify and/ or redistribute the software under the terms of the CeCILL     */
/*  license as circulated by CEA, CNRS and INRIA at the following URL          */
/*  "http://www.cecill.info".                                                  */
/*                                                                             */
/*  As a counterpart to the access to the source code and  rights to copy,     */
/*  modify and redistribute granted by the license, users are provided only    */
/*  with a limited warranty  and the software's author,  the holder of the     */
/*  economic rights,  and the successive licensors  have only  limited         */
/*  liability.                                                                 */
/*                                                                             */
/*  In this respect, the user's attention is drawn to the risks associated     */
/*  with loading,  using,  modifying and/or developing or reproducing the      */
/*  software by the user in light of its specific status of free software,     */
/*  that may mean  that it is complicated to manipulate,  and  that  also      */
/*  therefore means  that it is reserved for developers  and  experienced      */
/*  professionals having in-depth computer knowledge. Users are therefore      */
/*  encouraged to load and test the software's suitability as regards their    */
/*  requirements in conditions enabling the security of their systems and/or   */
/*  data to be ensured and,  more generally, to use and operate it in the      */
/*  same conditions as regards security.                                       */
/*                                                                             */
/*  The fact that you are presently reading this means that you have had       */
/*  knowledge of the CeCILL license and that you accept its terms.             */
/*******************************************************************************/

/*
 * libc includes
 */
#include <assert.h>
#include <stddef.h>
#include <stdio.h>
#include <string.h>

/*
 * xipfs includes
 */
#include "include/xipfs.h"
#include "include/buffer.h"
#include "include/errno.h"
#include "include/file.h"
#include "include/flash.h"

#if (defined(__ARM_ARCH_8M_MAIN__) || defined(__ARM_ARCH_8M_BASE__)) && \
    defined(XIPFS_ENABLE_SAFE_EXEC_SUPPORT)
#undef XIPFS_ENABLE_SAFE_EXEC_SUPPORT
#endif

#ifdef XIPFS_ENABLE_SAFE_EXEC_SUPPORT
#include "include/mpu_driver.h"
#endif

/*
 * Macro definitions
 */

/**
 * @internal
 *
 * @def XIPFS_FREE_RAM_SIZE
 *
 * @brief Amount of free RAM available for the relocatable
 * binary to use
 */
//#define XIPFS_FREE_RAM_SIZE (4096)
#define XIPFS_FREE_RAM_SIZE (1024*12)

/**
 * @internal
 *
 * @def EXEC_STACKSIZE_DEFAULT
 *
 * @brief The default execution stack size of the binary
 */
#define EXEC_STACKSIZE_DEFAULT 2048 // 1024

/**
 * @def EXC_RETURN_THREAD_MODE_PSP
 *
 * @brief The exec return adress to return from handler mode
 * to thread mode with psp stack
 */
#define EXC_RETURN_THREAD_MODE_PSP      0xFFFFFFFD

/**
 * @def XPSR_THUMB_MODE
 *
 * @brief The mask used during context switch to set xPSR to thumb mode,
 * it is mandatory to set xPSR to thumb mode to use exec return mechanism
 */
#define XPSR_THUMB_MODE                 0x1000000

#ifdef __GNUC__
/**
 * @internal
 *
 * @def NAKED
 *
 * @brief Indicates that the specified function does not need
 * prologue/epilogue sequences generated by the compiler
 */
#define NAKED __attribute__((naked))
/**
 * @internal
 *
 * @def UNUSED
 *
 * @brief Indicates that the specified variable or function may
 * be intentionally unused
 */
#define UNUSED __attribute__((unused))
/**
 * @internal
 *
 * @def USED
 *
 * @brief Indicates that the specified static variable or
 * function is to be retained in the object file, even if it is
 * unreferenced
 */
#define USED __attribute__((used))
#else
#error "sys/fs/file: Your compiler does not support GNU extensions"
#endif /* __GNUC__ */

/**
 * @internal
 *
 * @def STR_HELPER
 *
 * @brief Used for preprocessing in asm statements
 */
#define STR_HELPER(x) #x
/**
 * @internal
 *
 * @def STR
 *
 * @brief Used for preprocessing in asm statements
 */
#define STR(x)        STR_HELPER(x)

/**
 * @internal
 *
 * @brief Structure describing an exception stack frame,
 * used to switch between user / privileged mode
 */
typedef struct {
    /**
     * The r0 register
     */
    uint32_t r0;
    /**
     * The r1 register
     */
    uint32_t r1;
    /**
     * The r2 register
     */
    uint32_t r2;
    /**
     * The r3 register
     */
    uint32_t r3;
    /**
     * The r12 register
     */
    uint32_t r12;
    /**
     * The lr register
     */
    uint32_t lr;
    /**
     * The pc register
     */
    uint32_t pc;
    /**
     * The xPSR register
     */
    uint32_t xpsr;
} isr_stack_frame_t;

/**
 * @internal
 *
 * @brief An enumeration describing the different modes of the control register
 */
typedef enum control_register_mode_e {
    /**
     * Privileged mode with MSP stack
     */
    CTRL_PRIV_MSP = 0,
    /**
     * User mode with MSP stack
     */
    CTRL_USER_MSP = 1,
    /**
     * Privileged mode with PSP stack
     */
    CTRL_PRIV_PSP = 2,
    /**
     * User mode with PSP stack
     */
    CTRL_USER_PSP = 3
} control_register_mode_t;

/*
 * Internal structure
 */

/**
 * @internal
 *
 * @brief Data structure that describes the memory layout
 * required by the CRT0 to execute the relocatable binary
 */
typedef struct crt0_ctx_s {
    /**
     * Start address of the binary in the NVM
     */
    void *bin_base;
    /**
     * Start address of the available free RAM
     */
    void *ram_start;
    /**
     * End address of the available free RAM
     */
    void *ram_end;
    /**
     * Start address of the free NVM
     */
    void *nvm_start;
    /**
     * End address of the free NVM
     */
    void *nvm_end;
    /**
     * Start address of the file in NVM,
     * which is the text segment of the xipfs file.
     */
    void *file_base;
    /**
     * true if the context is executed in user mode with MPU regions configured,
     * false otherwise
     */
    unsigned char is_safe_call;
    /**
     * Number of arguments passed to the relocatable binary
     */
    int argc;
    /**
     * Arguments passed to the relocatable binary
     */
    char *argv[XIPFS_EXEC_ARGC_MAX];
    /**
     * Table of function pointers for functions
     * used by xipfs_format's CRT0 and/or stdriot.
     * These functions are not meant to be shared with
     * end users.
     */
    const void **xipfs_syscall_table;
    /**
     * Table of function pointers for the RIOT functions
     * used by the relocatable binary
     */
    const void **user_syscall_table;
    /**
     * When using xipfs_file_safe_exec, syscalls results will be written here.
     */
    int syscall_result;
} crt0_ctx_t;

/**
 * @internal
 *
 * @warning When modifying the structure here, please modify
 * also the structure declaration in xipfs_format/stdriot/stdriot.c.
 *
 * @brief Data structure that describes the execution context of
 * a relocatable binary
 */
typedef struct exec_ctx_s {
    /**
     * Data structure required by the CRT0 to execute the
     * relocatable binary
     */
    crt0_ctx_t *crt0_ctx;
    /**
     * Reserved memory space in RAM for the free RAM to be used
     * by the relocatable binary
     */
    //char ram_start[XIPFS_FREE_RAM_SIZE-1] __attribute__((aligned(XIPFS_FREE_RAM_SIZE)));
    char ram_start[XIPFS_FREE_RAM_SIZE-1] __attribute__((aligned(4096)));
    /**
     * Last byte of the free RAM
     */
    char ram_end;
    /**
     * Reserved memory space in RAM for the stack to be used by
     * the relocatable binary
     */
    char stkbot[EXEC_STACKSIZE_DEFAULT-4] __attribute__((aligned(EXEC_STACKSIZE_DEFAULT)));
    /**
     * Last word of the stack indicating the top of the stack
     */
    char stktop[4];
} exec_ctx_t;

/*
 * Global variables
 */

/**
 * @internal
 *
 * @brief The execution context of a relocatable binary
 */
static exec_ctx_t exec_ctx;

/**
 * @internal
 *
 * @brief A reference to the stack's state prior to invoking
 * execv(2)
 */
static void *_exec_curr_stack USED;

/**
 * @brief A pointer to a virtual file name
 */
char *xipfs_infos_file = "/.xipfs_infos";

#ifdef XIPFS_ENABLE_SAFE_EXEC_SUPPORT
/**
 * The mpu region identifier used to protect Text segment
 */
static xipfs_mpu_region_enum_t mpu_region_current_text;

#endif

/*
 * Helper functions
 */

/**
 * @internal
 *
 * @brief Local implementation of exit(3) passed to the binary
 * through the syscall table
 *
 * @param status The exit(3) status of the binary is stored in
 * the R0 register
 */
/* TODO: Move this function into board-specific functions */
static void NAKED
xipfs_exec_exit(int status UNUSED)
{
    __asm__ volatile
    (
        " ldr r4, =_exec_curr_stack \n"
        " ldr sp, [r4]              \n"
        " pop {r4, pc}              \n"
    );
}

/**
 * @internal
 *
 * @brief Starts the execution of the binary in the current RIOT
 * thread
 */
/* TODO: Move this function into board-specific functions */
static void NAKED
xipfs_exec_enter(void *crt0_ctx UNUSED,
                 void *entry_point UNUSED,
                 void *stack_top UNUSED)
{
    __asm__ volatile
    (
        " push {r4, lr}             \n"
        " ldr r4, =_exec_curr_stack \n"
        " str sp, [r4]              \n"
        " mov sp, r2                \n"
        " blx r1                    \n"
    );
}

/**
 * @internal
 *
 * @brief Converts an address into a thumb address
 *
 * @param addr The address to convert
 *
 * @return The converted address
 */
static inline void *thumb(void *addr)
{
    return (void *)((uintptr_t)addr | 1);
}

/**
 * @internal
 *
 * @brief Clean up the context of the relocatable binary
 *
 * @param exec_ctx The address of the context to clean up
 */
static inline void
exec_ctx_cleanup(exec_ctx_t *exec_ctx)
{
    (void)memset(exec_ctx, 0, sizeof(*exec_ctx));
}

/**
 * @internal
 *
 * @brief Fills the CRT0 data structure
 *
 * @param ctx A pointer to a memory region containing an
 * accessible execution context
 *
 * @param filp A pointer to a memory region containing an
 * accessible xipfs file structure
 */
static inline void
exec_ctx_crt0_init(exec_ctx_t *ctx, xipfs_file_t *filp)
{
    crt0_ctx_t *crt0_ctx;
    size_t size;
    void *end;

    /* Map crt0 context onto the stack */
    ctx->crt0_ctx = (crt0_ctx_t *)(void *)((&(ctx->stktop[4])) - sizeof(crt0_ctx_t));

    crt0_ctx = ctx->crt0_ctx;
    crt0_ctx->bin_base = filp->buf;
    crt0_ctx->ram_start = ctx->ram_start;
    crt0_ctx->ram_end = &ctx->ram_end;
    size = xipfs_file_get_size_(filp);
    crt0_ctx->nvm_start = &filp->buf[size];
    end = (char *)filp + filp->reserved;
    crt0_ctx->nvm_end = end;
    crt0_ctx->file_base = filp;
}

/**
 * @internal
 *
 * @brief Copies argument pointers to the execution context
 *
 * @param ctx A pointer to a memory region containing an
 * accessible execution context
 *
 * @param argv A pointer to a list of pointers to memory regions
 * containing accessible arguments to pass to the binary
 */
static inline void
exec_ctx_args_init(exec_ctx_t *ctx, char *const argv[])
{
    crt0_ctx_t *crt0_ctx = ctx->crt0_ctx;

    while (crt0_ctx->argc < XIPFS_EXEC_ARGC_MAX &&  argv[crt0_ctx->argc] != NULL) {
        crt0_ctx->argv[crt0_ctx->argc] = argv[crt0_ctx->argc];
        crt0_ctx->argc++;
    }
}

/**
 * @internal
 *
 * @brief Copies arguments to the execution context's stack.
 *
 * To be able to access executable arguments, these ones are copied into the stack,
 * and then are allowed to be read/written due to stack's MPU region.
 * Please note that this copy starts at crt0_ctx and goes backwards memory-wise.
 *
 * @param ctx A pointer to a memory region containing an
 * accessible execution context
 *
 * @param argv A pointer to a list of pointers to memory regions
 * containing accessible arguments to pass to the binary
 *
 * @retval NULL when there is not enough space left into the stack
 * to perform arguments copy.
 * @retval Pointer to the new stack top after arguments copy, otherwise.
 */
static inline char *
exec_ctx_args_init_safe(exec_ctx_t *ctx, char *const argv[])
{
    crt0_ctx_t *crt0_ctx = ctx->crt0_ctx;
    char *stack_ptr = (char *)crt0_ctx;
    size_t arg_length;


    while (crt0_ctx->argc < XIPFS_EXEC_ARGC_MAX &&  argv[crt0_ctx->argc] != NULL) {

        arg_length = strlen(argv[crt0_ctx->argc]);
        stack_ptr -= arg_length + 1;

        /* Do we have enough space left in the stack to copy the argument ? */
        if (stack_ptr < ctx->stkbot) {
            return NULL;
        }
        memcpy(stack_ptr, argv[crt0_ctx->argc], arg_length);
        stack_ptr[arg_length] = '\0';

        crt0_ctx->argv[crt0_ctx->argc] = stack_ptr;
        crt0_ctx->argc++;
    }

    /* Align the stack to a 4 bytes limit */
    stack_ptr -= ((int)stack_ptr) % 4;

    return stack_ptr;
}

/**
 * @brief An enumeration describing the index of xipfs functions.
 *
 * @warning MUST REMAIN SYNCHRONIZED with xipfs_format stdriot's one.
 */
typedef enum xipfs_syscall_e {
    XIPFS_SYSCALL_EXIT = XIPFS_USER_SYSCALL_MAX,
    XIPFS_SYSCALL_MAX,

    XIPFS_SYSCALL_FIRST = XIPFS_SYSCALL_EXIT,
    XIPFS_SYSCALL_LAST  = XIPFS_SYSCALL_MAX,
} xipfs_syscall_t;

#define XIPFS_SYSCALL_COUNT (XIPFS_SYSCALL_LAST - XIPFS_SYSCALL_FIRST + 1)

typedef int (*xipfs_syscall_exit_t)(int status);

static const void *xipfs_syscall_table[XIPFS_SYSCALL_COUNT] = {
    [XIPFS_SYSCALL_EXIT - XIPFS_SYSCALL_FIRST] = xipfs_exec_exit
};

/**
 * @internal
 *
 * @brief Sets the syscalls tables in execution context.
 *
 * @param ctx A pointer to a memory region containing an
 * accessible execution context
 *
 * @see xipfs_syscall_t.
 * @see xipfs_user_syscall_t.
 */
static inline void
exec_ctx_syscall_init(exec_ctx_t *ctx,
                      const void *user_syscalls[XIPFS_USER_SYSCALL_MAX])
{
    ctx->crt0_ctx->xipfs_syscall_table = xipfs_syscall_table;
    ctx->crt0_ctx->user_syscall_table  = user_syscalls;
}

static inline void
exec_ctx_syscall_init_safe(exec_ctx_t *ctx,
                           const void *user_syscalls[XIPFS_USER_SYSCALL_MAX])
{
    ctx->crt0_ctx->xipfs_syscall_table = NULL;
    ctx->crt0_ctx->user_syscall_table  = user_syscalls;
}

/**
 * @internal
 *
 * @brief Execution context initializer.
 *
 * @param exec_ctx The execution context to initialize
 * @param filp The file pointer from where to run execution
 * @param argv the execution arguments
 * @param user_syscalls The user syscalls table
 */
static inline void
exec_ctx_init(exec_ctx_t *exec_ctx, xipfs_file_t *filp,
              char *const argv[],
              const void *user_syscalls[XIPFS_USER_SYSCALL_MAX])
{
    exec_ctx_crt0_init(exec_ctx, filp);
    exec_ctx_args_init(exec_ctx, argv);
    exec_ctx_syscall_init(exec_ctx, user_syscalls);
}

/**
 * @internal
 *
 * @brief Execution context initializer.
 *
 * This function will :
 * - map exec_ctx->crt0 onto the stack space,
 * - then copy after the arguments into stack,
 * - and finally set syscalls tables.
 *
 * @param exec_ctx The execution context to initialize
 * @param filp The file pointer from where to run execution
 * @param argv the execution arguments
 * @param user_syscalls The user syscalls table
 *
 * @retval NULL when there is not enough space left into the stack
 * to perform arguments copy.
 * @retval Pointer to the new stack top after arguments copy, otherwise.
 */
static inline char *
exec_ctx_init_safe(exec_ctx_t *exec_ctx, xipfs_file_t *filp,
                   char *const argv[],
                   const void *user_syscalls[XIPFS_USER_SYSCALL_MAX])
{
    char *stack_top;
    exec_ctx_crt0_init(exec_ctx, filp);
    stack_top = exec_ctx_args_init_safe(exec_ctx, argv);
    if(stack_top == NULL)
        return NULL;

    exec_ctx_syscall_init_safe(exec_ctx, user_syscalls);
    return stack_top;
}

/*
 * Extern functions
 */

/**
 * @internal
 *
 * @brief Checks if the character passed as an argument is in
 * the xipfs charset
 *
 * @param c The character to check
 *
 * @return Returns one if the character passed as an argument is
 * in the xipfs charset or a zero otherwise
 */
static int
xipfs_file_path_charset_check(char c)
{
    return (c >= '0' && c <= '9') ||
           (c >= 'A' && c <= 'Z') ||
           (c >= 'a' && c <= 'z') ||
            c == '/' || c == '.'  ||
            c == '-' || c == '_';
}

/**
 * @pre path must be a pointer that references a path which is
 * accessible, null-terminated, starts with a slash, normalized,
 * and shorter than XIPFS_PATH_MAX
 *
 * @brief Checks if the path passed as an argument is a valid
 * xipfs path
 *
 * @param path The path to check
 *
 * @return Returns zero if the path passed an an argument is a
 * valid xipfs path or a negative value otherwise
 */
int
xipfs_file_path_check(const char *path)
{
    size_t i;

    if (path == NULL) {
        xipfs_errno = XIPFS_ENULLP;
        return -1;
    }
    if (path[0] == '\0') {
        xipfs_errno = XIPFS_EEMPTY;
        return -1;
    }
    for (i = 0; i < XIPFS_PATH_MAX && path[i] != '\0'; i++) {
        if (xipfs_file_path_charset_check(path[i]) == 0) {
            xipfs_errno = XIPFS_EINVAL;
            return -1;
        }
    }
    if (path[i] != '\0') {
        xipfs_errno = XIPFS_ENULTER;
        return -1;
    }

    return 0;
}

/**
 * @pre filp must be a pointer to an accessible and valid xipfs
 * file structure
 *
 * @brief Checks if the xipfs file structure passed as an
 * argument is a valid one
 *
 * @param filp The xipfs file structure to check
 *
 * @return Returns zero if the xipfs file structure passed as an
 * argument is a valid one or a negative value otherwise
 */
int
xipfs_file_filp_check(xipfs_file_t *filp)
{
    if (filp == NULL) {
        xipfs_errno = XIPFS_ENULLF;
        return -1;
    }
    if (xipfs_flash_page_aligned(filp) < 0) {
        xipfs_errno = XIPFS_EALIGN;
        return -1;
    }
    if (xipfs_flash_in(filp) < 0) {
        xipfs_errno = XIPFS_EOUTNVM;
        return -1;
    }
    if (filp->next == NULL) {
        xipfs_errno = XIPFS_ENULLF;
        return -1;
    }
    if (filp->next != filp) {
        if (xipfs_flash_page_aligned(filp->next) == 0) {
            xipfs_errno = XIPFS_EALIGN;
            return -1;
        }
        if (xipfs_flash_in(filp->next) == 0) {
            xipfs_errno = XIPFS_EOUTNVM;
            return -1;
        }
        if ((uintptr_t)filp >= (uintptr_t)filp->next) {
            xipfs_errno = XIPFS_ELINK;
            return -1;
        }
        if ((uintptr_t)filp + filp->reserved != (uintptr_t)filp->next) {
            xipfs_errno = XIPFS_ELINK;
            return -1;
        }
    }
    if (xipfs_file_path_check(filp->path) < 0) {
        /* xipfs_errno was set */
        return -1;
    }
    if (filp->exec != 0 && filp->exec != 1) {
        xipfs_errno = XIPFS_EPERM;
        return -1;
    }

    return 0;
}

/**
 * @pre vfs_filp must be a pointer to an accessible and valid
 * VFS file structure
 *
 * @brief Retrieves the maximum possible position of a file
 *
 * @param vfs_filp A pointer to a memory region containing a
 * VFS file structure
 *
 * @return Returns the maximum possible position of the file or
 * a negative value otherwise
 */
off_t
xipfs_file_get_max_pos(xipfs_file_t *filp)
{
    off_t max_pos;

    assert(filp != NULL);

    if (xipfs_file_filp_check(filp) < 0) {
        /* xipfs_errno was set */
        return -1;
    }
    max_pos  = (off_t)filp->reserved;
    max_pos -= (off_t)sizeof(*filp);

    return max_pos;
}

/**
 * @pre vfs_filp must be a pointer to an accessible and valid
 * VFS file structure
 *
 * @brief Retrieves the reserved size of a file
 *
 * @param vfs_filp A pointer to a memory region containing a
 * VFS file structure
 *
 * @return Returns the reserved size of the file or a negative
 * value otherwise
 */
off_t
xipfs_file_get_reserved(xipfs_file_t *filp)
{
    off_t reserved;

    assert(filp != NULL);

    if (xipfs_file_filp_check(filp) < 0) {
        /* xipfs_errno was set */
        return -1;
    }
    reserved = (off_t)filp->reserved;

    return reserved;
}

/**
 * @pre filp must be a pointer to an accessible and valid xipfs
 * file structure
 *
 * @brief Removes a file from the file system
 *
 * @param filp A pointer to a memory region containing an
 * accessible xipfs file structure
 *
 * @return Returns zero if the function succeeds or a negative
 * value otherwise
 */
int
xipfs_file_erase(xipfs_file_t *filp)
{
    unsigned start, number, i;

    if (xipfs_file_filp_check(filp) < 0) {
        /* xipfs_errno was set */
        return -1;
    }

    start = xipfs_nvm_page(filp);
    number = filp->reserved / XIPFS_NVM_PAGE_SIZE;

    for (i = 0; i < number; i++) {
        if (xipfs_flash_erase_page(start + i) < 0) {
            /* xipfs_errno was set */
            return -1;
        }
    }

    return 0;
}

/**
 * @pre filp must be a pointer to an accessible and valid xipfs
 * file structure
 *
 * @brief Retrieves the current file size from the list of
 * previous sizes
 *
 * @param filp A pointer to a memory region containing an
 * accessible xipfs file structure
 *
 * @return Returns the current file size or a negative value
 * otherwise
 */
off_t
xipfs_file_get_size_(xipfs_file_t *filp)
{
    size_t i = 1;
    off_t size;

    if (filp->size[0] == (size_t)XIPFS_FLASH_ERASE_STATE) {
        /* file size not in flash yet */
        return 0;
    }

    while (i < XIPFS_FILESIZE_SLOT_MAX) {
        if (filp->size[i] == (size_t)XIPFS_FLASH_ERASE_STATE) {
            return (off_t)filp->size[i-1];
        }
        i++;
    }

    if (xipfs_buffer_read_32((unsigned *)&size, &filp->size[i-1]) < 0) {
        /* xipfs_errno was set */
        return -1;
    }

    return size;
}

/**
 * @pre vfs_filp must be a pointer to an accessible and valid
 * xipfs file structure
 *
 * @brief Wrapper to the xipfs_file_get_size_ function that
 * checks the validity of the xipfs file strucutre
 *
 * @param vfs_filp A pointer to a memory region containing an
 * accessible xipfs file structure
 *
 * @return Returns the current file size or a negative value
 * otherwise
 */
off_t
xipfs_file_get_size(xipfs_file_t *filp)
{
    if (xipfs_file_filp_check(filp) < 0) {
        /* xipfs_errno was set */
        return -1;
    }

    return xipfs_file_get_size_(filp);
}

/**
 * @pre filp must be a pointer to an accessible and valid xipfs
 * file structure
 *
 * @brief Sets the new file size to the list of previous sizes
 *
 * @param vfs_fp A pointer to a memory region containing an
 * accessible xipfs file structure
 *
 * @param size The size to set to the file
 *
 * @return Returns zero if the function succeed or a negative
 * value otherwise
 */
int
xipfs_file_set_size(xipfs_file_t *filp, off_t size)
{
    size_t i = 1;

    if (xipfs_file_filp_check(filp) < 0) {
        /* xipfs_errno was set */
        return -1;
    }

    while (i < XIPFS_FILESIZE_SLOT_MAX) {
        if (filp->size[i] != (size_t)XIPFS_FLASH_ERASE_STATE) {
            break;
        }
        i++;
    }
    i %= XIPFS_FILESIZE_SLOT_MAX;

    if (xipfs_buffer_write_32(&filp->size[i], size) < 0) {
        /* xipfs_errno was set */
        return -1;
    }

    if (xipfs_buffer_flush() < 0) {
        /* xipfs_errno was set */
        return -1;
    }

    return 0;
}

/**
 * @pre filp must be a pointer to an accessible and valid xipfs
 * file structure
 *
 * @pre path must be a pointer that references a path which is
 * accessible, null-terminated, starts with a slash, normalized,
 * and shorter than XIPFS_PATH_MAX
 *
 * @brief Changes the path of an xipfs file
 *
 * @param filp A pointer to a memory region containing an
 * accessible xipfs file structure
 *
 * @param to_path The new path of the file
 *
 * @return Returns zero if the function succeed or a negative
 * value otherwise
 */
int
xipfs_file_rename(xipfs_file_t *filp, const char *to_path)
{
    size_t len;

    if (xipfs_file_filp_check(filp) < 0) {
        /* xipfs_errno was set */
        return -1;
    }

    if (xipfs_file_path_check(to_path) < 0) {
        /* xipfs_errno was set */
        return -1;
    }

    len = strlen(to_path) + 1;

    if (xipfs_buffer_write(filp->path, to_path, len) < 0) {
        /* xipfs_errno was set */
        return -1;
    }

    if (xipfs_buffer_flush() < 0) {
        /* xipfs_errno was set */
        return -1;
    }

    return 0;
}

/**
 * @pre vfs_filp must be a pointer to an accessible and valid VFS
 * file structure
 *
 * @brief Reads a byte from the current position of the open VFS
 * file
 *
 * @param vfs_filp A pointer to a memory region containing an
 * accessible and open VFS file structure
 *
 * @param byte A pointer to a memory region where to store the
 * read byte
 *
 * @return Returns zero if the function succeed or a negative
 * value otherwise
 */
int
xipfs_file_read_8(xipfs_file_t *filp, off_t pos, char *byte)
{
    off_t pos_max;

    if (xipfs_file_filp_check(filp) < 0) {
        /* xipfs_errno was set */
        return -1;
    }
    if ((pos_max = xipfs_file_get_max_pos(filp)) < 0) {
        /* xipfs_errno was set */
        return -1;
    }
    /* since off_t is defined as a signed integer type, we must
     * verify that the value is non-negative */
    if (pos < 0 || pos > pos_max) {
        xipfs_errno = XIPFS_EMAXOFF;
        return -1;
    }
    if (xipfs_buffer_read_8(byte, &filp->buf[pos]) < 0) {
        /* xipfs_errno was set */
        return -1;
    }

    return 0;
}

/**
 * @pre vfs_filp must be a pointer to an accessible and valid VFS
 * file structure
 *
 * @brief Writes a byte from to the current position of the open
 * VFS file
 *
 * @param vfs_filp A pointer to a memory region containing an
 * accessible and open VFS file structure
 *
 * @param byte The byte to write to the current position of the
 * open file
 *
 * @return Returns zero if the function succeed or a negative
 * value otherwise
 */
int
xipfs_file_write_8(xipfs_file_t *filp, off_t pos, char byte)
{
    off_t pos_max;

    if (xipfs_file_filp_check(filp) < 0) {
        /* xipfs_errno was set */
        return -1;
    }
    if ((pos_max = xipfs_file_get_max_pos(filp)) < 0) {
        /* xipfs_errno was set */
        return -1;
    }
    /* since off_t is defined as a signed integer type, we must
     * verify that the value is non-negative */
    if (pos < 0 || pos > pos_max) {
        xipfs_errno = XIPFS_EMAXOFF;
        return -1;
    }
    if (xipfs_buffer_write_8(&filp->buf[pos], byte) < 0) {
        /* xipfs_errno was set */
        return -1;
    }

    return 0;
}

/**
 * @pre filp must be a pointer to an accessible and valid xipfs
 * file structure
 *
 * @brief Executes a binary in the current RIOT thread
 *
 * @param filp A pointer to a memory region containing an
 * accessible xipfs file structure
 *
 * @param argv A pointer to a list of pointers to memory regions
 * containing accessible arguments to pass to the binary
 *
 * @param user_syscalls A pointer to a list of pointers defining a syscalls
 * table as stated by xipfs_user_syscall_t.
 *
 * @return Returns zero if the function succeed or a negative
 * value otherwise
 */
int
xipfs_file_exec(xipfs_file_t *filp, char *const argv[],
                const void *user_syscalls[XIPFS_USER_SYSCALL_MAX])
{
    void *exec_entry_point;

    if (xipfs_file_filp_check(filp) < 0) {
        /* xipfs_errno was set */
        return -1;
    }

    exec_ctx_cleanup(&exec_ctx);
    exec_ctx_init(&exec_ctx, filp, argv, user_syscalls);
    exec_ctx.crt0_ctx->is_safe_call = 0;
    exec_entry_point = thumb(&filp->buf[0]);
    xipfs_exec_enter(exec_ctx.crt0_ctx, exec_entry_point, exec_ctx.crt0_ctx);

    return 0;
}

#ifdef XIPFS_ENABLE_SAFE_EXEC_SUPPORT

/**
 * @internal
 *
 * @pre Should be only called by xipfs_file_safe_exec
 *
 * @brief disables all xipfs regions, restores mpu state and interruptions.
 *
 * @param mpu_was_enabled Mpu state to restore or not.
 */
static void on_mpu_setting_error(bool mpu_was_enabled) {
    for (int i = XIPFS_MPU_REGION_ENUM_FIRST; i <= XIPFS_MPU_REGION_ENUM_LAST; ++i)
        (void)mpu_configure((uint_fast8_t)i, 0, 0);

    if (mpu_was_enabled)
        (void)mpu_enable();

    __DSB();
    __ISB();
    __enable_irq();
}

/**
 * @internal
 *
 * @pre filp must be a pointer to an accessible and valid xipfs
 * file structure
 *
 * @brief Calls an SVC to switch from thread mode to handler mode
 * and be able to switch to user thread mode safely
 *
 * @param crt0 A pointer to the crt0 context to execute the binary
 *
 * @param entrypoint A pointer to the entrypoint of the binary
 *
 * @param stack A pointer to the top of the binary's stack
 */
static void NAKED xipfs_file_safe_exec_svc(crt0_ctx_t *crt0 UNUSED, void *entrypoint UNUSED, void *stack UNUSED) {
    /**
     * The arguments are passed to the SVC call through r0, r1, and r2
     */
    __asm__ volatile(
        " push   {lr}                        \n"
        " ldr    r4, =_exec_curr_stack       \n" // get the current stack
        " str    sp, [r4]                    \n" // save current SP
        " svc #" STR(XIPFS_ENTER_SVC_NUMBER) " \n");
}

#endif /* XIPFS_ENABLE_SAFE_EXEC_SUPPORT */

/**
 * @pre filp must be a pointer to an accessible and valid xipfs
 * file structure
 *
 * @brief Executes a binary in user mode protected by the MPU in the current RIOT thread
 *
 * @param filp A pointer to a memory region containing an
 * accessible xipfs file structure
 *
 * @param argv A pointer to a list of pointers to memory regions
 * containing accessible arguments to pass to the binary
 *
 * @param user_syscalls A pointer to a list of pointers defining a syscalls
 * table as stated by xipfs_user_syscall_t.
 *
 * @return Returns zero if the function succeed or a negative
 * value otherwise
 */
int xipfs_file_safe_exec(xipfs_file_t *filp, char *const argv[],
                         const void *user_syscalls[XIPFS_USER_SYSCALL_MAX])
{
#if defined(XIPFS_ENABLE_SAFE_EXEC_SUPPORT)
    void *exec_entry_point;
    int status = -1;
    bool mpu_was_enabled;
    char *stack_top;

    if (xipfs_file_filp_check(filp) < 0) {
        /* xipfs_errno was set */
        return -1;
    }

    /* Initialize exec_ctx */
    exec_ctx_cleanup(&exec_ctx);
    stack_top = exec_ctx_init_safe(&exec_ctx, filp, argv, user_syscalls);

    if(stack_top == NULL) {
        return -1;
    }

    /* Check exec_ctx member alignments */
    if (!(
              ((uint32_t)exec_ctx.stkbot % EXEC_STACKSIZE_DEFAULT == 0)
           && ((uint32_t)exec_ctx.ram_start % 4096 == 0)
           && ((uint32_t)exec_ctx.crt0_ctx->file_base % XIPFS_NVM_PAGE_SIZE == 0)
         )) {
        xipfs_errno = XIPFS_EALIGN;
        return -1;
    }

    exec_ctx.crt0_ctx->is_safe_call = 1;
    exec_entry_point = thumb(&filp->buf[0]);

    /* IRQ and MPU off */
    __disable_irq();

    if (mpu_enabled()) {
        mpu_was_enabled = true;

        if (mpu_disable() < 0) {
            __enable_irq();
            xipfs_errno = XIPFS_EDISABLEMPU;
            return -1;
        }
    } else
        mpu_was_enabled = false;

    /* Set MPU regions for text, data and stack */

    /*
     * Regarding to the TEXT segment, we use 2 MPU regions
     * that are set alternatively according to MPU faults.
     * This scheme allows to handle instructions which would be
     * astride the boundary of 2 memory regions.
     */
    mpu_region_current_text = XIPFS_MPU_REGION_ENUM_TEXT;
    if (xipfs_mpu_configure_region(
            mpu_region_current_text,
            filp, XIPFS_NVM_PAGE_SIZE,
            XIPFS_MPU_REGION_EXC_OK, XIPFS_MPU_REGION_AP_RO_RO) < 0) {

        on_mpu_setting_error(mpu_was_enabled);
        xipfs_errno = XIPFS_ETEXTREGION;
        return -1;
    }

    /*
     * For the DATA segment, we can take advantage of the data size,
     * fixed to 12 KB while aligning the ram to 4 KB boundaries.
     * Within these conditions, it is possible to set 2 regions once
     * for all, with no dynamic region assignments.
     *
     * When the ram is aligned to a 8 Kb boundary :
     * - Set the first region A to {ram start, 8 KB size};
     * - Set the second region B to {ram start + 8 KB, 4 KB size}.
     *
     * +--------+----+
     * |    A   |  B |
     * +--------+----+
     * |        |    |
     * |        |    .-- Ram start + 12 KB
     * |        .------- Ram start + 8 KB
     * .---------------- Ram starts at a 8KB boundary
     *
     * When the ram is aligned to a (8 + 4) KB boundary (which is a 4 KB boundary) :
     * - Set the first region A to {ram start, 4 KB size};
     * - Set the second region B to {ram start + 4 KB, 8 KB size}.
     * +----+--------+
     * |  A |    B   |
     * +----+--------+
     * |    |        |
     * |    |        .-- Ram start + 12 KB
     * |    .----------- Ram start + 4 KB
     * .---------------- Ram starts at a 4 KB boundary, while not being a 8 KB one.
     *
     * These two cases cover up the whole 12 KB of ram, with no need for dynamic regions setting.
     */
    /* Are we on a 8 KB boundary ? */
    if ( ((((uint32_t)exec_ctx.ram_start) >> 12) & 1) == 0 ) {
        if (xipfs_mpu_configure_region(
                XIPFS_MPU_REGION_ENUM_DATA,
                exec_ctx.crt0_ctx->ram_start, 8192,
                XIPFS_MPU_REGION_EXC_NO, XIPFS_MPU_REGION_AP_RW_RW) < 0) {

            on_mpu_setting_error(mpu_was_enabled);

            xipfs_errno = XIPFS_EDATAREGION;
            return -1;
        }

        if (xipfs_mpu_configure_region(
                XIPFS_MPU_REGION_ENUM_EXTRA_DATA,
                exec_ctx.crt0_ctx->ram_start + 8192, 4096,
                XIPFS_MPU_REGION_EXC_NO, XIPFS_MPU_REGION_AP_RW_RW) < 0) {

            on_mpu_setting_error(mpu_was_enabled);

            xipfs_errno = XIPFS_EDATAREGION;
            return -1;
        }

    } else {
        if (xipfs_mpu_configure_region(
                XIPFS_MPU_REGION_ENUM_DATA,
                exec_ctx.crt0_ctx->ram_start, 4096,
                XIPFS_MPU_REGION_EXC_NO, XIPFS_MPU_REGION_AP_RW_RW) < 0) {

            on_mpu_setting_error(mpu_was_enabled);

            xipfs_errno = XIPFS_EDATAREGION;
            return -1;
        }

        if (xipfs_mpu_configure_region(
                XIPFS_MPU_REGION_ENUM_EXTRA_DATA,
                exec_ctx.crt0_ctx->ram_start + 4096, 8192,
                XIPFS_MPU_REGION_EXC_NO, XIPFS_MPU_REGION_AP_RW_RW) < 0) {

            on_mpu_setting_error(mpu_was_enabled);

            xipfs_errno = XIPFS_EDATAREGION;
            return -1;
        }
    }

    /*
     * At last, STACK segment is merely handled by a single MPU region,
     * without any dynamic modification.
     */
    if (xipfs_mpu_configure_region(
            XIPFS_MPU_REGION_ENUM_STACK,
            exec_ctx.stkbot, EXEC_STACKSIZE_DEFAULT,
            XIPFS_MPU_REGION_EXC_NO, XIPFS_MPU_REGION_AP_RW_RW) < 0) {

        on_mpu_setting_error(mpu_was_enabled);

        xipfs_errno = XIPFS_ESTACKREGION;
        return -1;
    }


    /* Enable MPU if it is not already */
    if (mpu_enable() != 0) {
        on_mpu_setting_error(false);
        xipfs_errno = XIPFS_EENABLEMPU;
        return -1;
    }

    __DSB();
    __ISB();
    __enable_irq();

    __asm__ volatile(
        " mrs r0, msp           \n" // save main stack pointer
        " push {r0, r4-r11, lr} \n" // save registers
    );

    xipfs_file_safe_exec_svc(exec_ctx.crt0_ctx, exec_entry_point, stack_top);

    __asm__ volatile(
        " pop {r1, r4-r11, lr} \n" // restore registers
        " msr msp, r1          \n" // restore main stack pointer
        " mov %0, r0           \n" // retrieve exec status
        : "=r"(status)
    );

    __disable_irq();

    /* Disable MPU regions */
    if (mpu_disable() != 0) {
        xipfs_errno = XIPFS_EDISABLEMPU;
        __enable_irq();
        return -1;
    }

    for (xipfs_mpu_region_enum_t i = XIPFS_MPU_REGION_ENUM_FIRST;
         i <= XIPFS_MPU_REGION_ENUM_LAST; ++i) {
        MPU->RNR = i;
        MPU->RASR &= ~MPU_RASR_ENABLE_Msk;
    }

    /* Restore MPU if it was enabled before calling this function */
    if (mpu_was_enabled && (mpu_enable() != 0)) {
        xipfs_errno = XIPFS_EENABLEMPU;
        __enable_irq();
        return -1;
    }

    __DSB();
    __ISB();
    __enable_irq();

    return status;
#else /* XIPFS_ENABLE_SAFE_EXEC_SUPPORT */
    (void)filp;
    (void)argv;
    (void)user_syscalls;
    xipfs_errno = XIPFS_ENOSAFESUPPORT;
    return -1;
#endif /* XIPFS_ENABLE_SAFE_EXEC_SUPPORT */
}

#ifdef XIPFS_ENABLE_SAFE_EXEC_SUPPORT

/**
 * @internal
 *
 * @pre control param should be at least 2 because SPSEL bit of the control register should be 1,
 * it means that we should always return from the exception with the psp stack
 *
 * @pre we must be in handler mode to use the exec return mechanism,
 * otherwise an hard fault exception will occur
 *
 * @brief Switch to the context specified with the exception frame
 * stored in the last 32 bytes of the stack parameter and restore the former isr stack start.
 * It uses the arm exec return mechanism to switch safely between user / privileged mode
 *
 * @param stack A pointer to the stack to use after the context switch
 *
 * @param control The flags of the control register to specify if we return in user or privileged mode
 *
 * @param isr_stack_start A pointer to the exception stack top, we must restore it because we never
 * return from the exception
 */
static void NAKED xipfs_switch_context(void *stack UNUSED,
                                       control_register_mode_t control UNUSED,
                                       void *isr_stack_top UNUSED)
{
    __asm__ volatile(
        "cpsid i                                      \n" /* disable interrupts */
        /* Switch to thread mode with psp stack */
        "msr psp, r0                                  \n" /* set psp to begin of stack frame */
        "msr msp, r2                                  \n" /* restore isr stack to end because we never return from the interrupt */
        "msr control, r1                              \n" /* set the control register to control arg */
        "isb                                          \n"
        "ldr r0, =" STR(EXC_RETURN_THREAD_MODE_PSP) " \n" /* exec return to thread mode using psp */
        "cpsie i                                      \n" /* enable interrupts */
        "bx r0                                        \n" /* jump to exec return to thread mode with psp */
    );
}

/**
 * @internal
 *
 * @brief Initialize an exception stack frame by setting all members to zero
 * except from xpsr which is set to thumb mode for switching
 *
 * @param frame A pointer to the exception stack frame used to switch context
 */
static void init_isr_stack_frame(isr_stack_frame_t *frame)
{
    memset(frame, 0, 28);
    frame->xpsr = XPSR_THUMB_MODE;
}

/**
 * Provided by OS host.
 */
extern void *thread_isr_stack_end(void);

void xipfs_safe_exec_enter(void *crt0_ctx,
                           void *entrypoint,
                           void *stack)
{
    uint32_t *stack_ptr = (uint32_t *)stack;
    stack_ptr -= 8;

    isr_stack_frame_t *frame = (isr_stack_frame_t *)stack_ptr;
    init_isr_stack_frame(frame);
    frame->r0 = (uint32_t)crt0_ctx;
    frame->pc = (uint32_t)entrypoint;

    void *isr_stack_top = thread_isr_stack_end();
    xipfs_switch_context(stack_ptr, CTRL_USER_PSP, isr_stack_top);
}

/**
 * @internal
 *
 * @pre we must be in handler mode to use the function, otherwise an hard fault
 * will occur on context switch
 *
 * @brief Prepare the exception stack frame to switch back from user mode to
 * privileged mode and exit safely
 *
 * @param status The return status of the safe call
 */
static void xipfs_safe_exec_exit(int status)
{
    uint32_t *current_stack_ptr = (uint32_t *)_exec_curr_stack;
    uint32_t return_address = *current_stack_ptr;
    current_stack_ptr -= 7; // 7 * 4 = 28, not 32 bytes because we deallocate the return address of 4 bytes

    isr_stack_frame_t *frame = (isr_stack_frame_t *)current_stack_ptr;
    init_isr_stack_frame(frame);
    frame->pc = return_address;
    frame->r0 = status;

    void *isr_stack_top = thread_isr_stack_end();
    xipfs_switch_context(current_stack_ptr, CTRL_PRIV_PSP, isr_stack_top);
}

/**
 * @internal
 *
 * @brief Check if a value is within a specified range
 *
 * @param value The value to check
 *
 * @param begin The beginning of the range
 *
 * @param end The end of the range
 *
 * @return True if the address is withing the specified range, false otherwise
 */
static bool is_value_in_range(uint32_t value, uint32_t begin, uint32_t end)
{
    return value >= begin && value <= end;
}

int xipfs_mem_manage_handler(void *isr_frame_ptr, uint32_t mmfar, uint32_t cfsr)
{
    isr_stack_frame_t *frame = (isr_stack_frame_t *)isr_frame_ptr;
    uint32_t fault_addr = cfsr & SCB_CFSR_MMARVALID_Msk ? mmfar : frame->pc;

    __disable_irq();
    if (mpu_disable() != 0) {
        __enable_irq();
        return -1;
    }

    /* Check if the stack frame is in user stack */
    if (is_value_in_range((uint32_t)isr_frame_ptr,
                          (uint32_t)exec_ctx.stkbot,
                          (uint32_t)exec_ctx.stktop + 4) == false) {
        (void)mpu_enable();
        __enable_irq();
        return -2;
    }

    /* Is this a text portion that is faulting ? */
    if (is_value_in_range(  fault_addr,
                            (uint32_t)exec_ctx.crt0_ctx->file_base,
                            (uint32_t)exec_ctx.crt0_ctx->nvm_end) == false) {
        printf("Illegal memory access detected at 0x%lx.\n", fault_addr);
        (void)mpu_enable();
        __enable_irq();

        SCB->CFSR = SCB_CFSR_MEMFAULTSR_Msk; /* write-1-to-clear */

        xipfs_safe_exec_exit(-1);
        // Should never be reached.
        return -3;
    }

    /* Set a new text region */
    if (mpu_region_current_text == XIPFS_MPU_REGION_ENUM_TEXT)
        mpu_region_current_text = XIPFS_MPU_REGION_ENUM_EXTRA_TEXT;
    else
        mpu_region_current_text = XIPFS_MPU_REGION_ENUM_TEXT;

    /* The region must be aligned with XIPFS_NVM_PAGE_SIZE and must contain fault_addr */
    fault_addr = (fault_addr / XIPFS_NVM_PAGE_SIZE) * XIPFS_NVM_PAGE_SIZE;

    if (xipfs_mpu_configure_region(
            mpu_region_current_text,
            (char *)fault_addr, XIPFS_NVM_PAGE_SIZE,
            XIPFS_MPU_REGION_EXC_OK, XIPFS_MPU_REGION_AP_RO_RO) < 0) {
        (void)mpu_enable();
        __enable_irq();
        return -4;
    }

    SCB->CFSR = SCB_CFSR_MEMFAULTSR_Msk; /* write-1-to-clear */

    (void)mpu_enable();
    __DSB();
    __ISB();
    __enable_irq();

    return 0;
}

/**
 * @internal
 * @remarks This function uses the user syscall table in exec_ctx.
 * That means that functions called here are RIOT's ones, except from
 * XIPFS_SYSCALL_EXIT.
 *
 * @remarks long and ssize_t are 32 bits wide on arm 32bits.
 */
void xipfs_syscall_dispatcher(unsigned int *svc_args)
{
    unsigned int syscall_number = svc_args[0];
    crt0_ctx_t *crt0_ctx = exec_ctx.crt0_ctx;

    switch (syscall_number) {
    case XIPFS_SYSCALL_EXIT: {
        int ret_status = svc_args[1];
        xipfs_safe_exec_exit(ret_status);
        break;
    }
    case XIPFS_USER_SYSCALL_PRINTF: {
        const char *format = (const char *)svc_args[1];
        va_list *ap = (va_list *)svc_args[2];
        xipfs_user_syscall_vprintf_t f = (xipfs_user_syscall_vprintf_t)
            crt0_ctx->user_syscall_table[XIPFS_USER_SYSCALL_PRINTF];
        crt0_ctx->syscall_result = f(format, *ap);
        break;
    }
    case XIPFS_USER_SYSCALL_GET_TEMP: {
        xipfs_user_syscall_get_temp_t f = (xipfs_user_syscall_get_temp_t)
            crt0_ctx->user_syscall_table[XIPFS_USER_SYSCALL_GET_TEMP];
        crt0_ctx->syscall_result = f();
        break;
    }
    case XIPFS_USER_SYSCALL_ISPRINT: {
        int character = (int)svc_args[1];
        xipfs_user_syscall_isprint_t f = (xipfs_user_syscall_isprint_t)
        crt0_ctx->user_syscall_table[XIPFS_USER_SYSCALL_ISPRINT];
        crt0_ctx->syscall_result = f(character);
        break;
    }
    case XIPFS_USER_SYSCALL_STRTOL: {
        const char *str = (const char *)svc_args[1];
        char **endptr = (char **)svc_args[2];
        int base = (int)svc_args[3];
        xipfs_user_syscall_strtol_t f = (xipfs_user_syscall_strtol_t)
            crt0_ctx->user_syscall_table[XIPFS_USER_SYSCALL_STRTOL];
        crt0_ctx->syscall_result = f(str, endptr, base);
        break;
    }
    case XIPFS_USER_SYSCALL_GET_LED: {
        int pos = (int)svc_args[1];
        xipfs_user_syscall_get_led_t f = (xipfs_user_syscall_get_led_t)
            crt0_ctx->user_syscall_table[XIPFS_USER_SYSCALL_GET_LED];
        crt0_ctx->syscall_result = f(pos);
        break;
    }
    case XIPFS_USER_SYSCALL_SET_LED: {
        int pos = (int)svc_args[1];
        int val = (int)svc_args[2];
        xipfs_user_syscall_set_led_t f = (xipfs_user_syscall_set_led_t)
            crt0_ctx->user_syscall_table[XIPFS_USER_SYSCALL_SET_LED];
        crt0_ctx->syscall_result = f(pos, val);
        break;
    }
    case XIPFS_USER_SYSCALL_COPY_FILE: {
        const char *name = (const char *)svc_args[1];
        void *buf = (void *)svc_args[2];
        size_t nbyte = (size_t)svc_args[3];
        xipfs_user_syscall_copy_file_t f = (xipfs_user_syscall_copy_file_t)
            crt0_ctx->user_syscall_table[XIPFS_USER_SYSCALL_COPY_FILE];
        crt0_ctx->syscall_result = f(name, buf, nbyte);
        break;
    }
    case XIPFS_USER_SYSCALL_GET_FILE_SIZE: {
        const char *name = (const char *)svc_args[1];
        size_t *size = (size_t *)svc_args[2];
        xipfs_user_syscall_get_file_size_t f = (xipfs_user_syscall_get_file_size_t)
            crt0_ctx->user_syscall_table[XIPFS_USER_SYSCALL_GET_FILE_SIZE];
        crt0_ctx->syscall_result = f(name, size);
        break;
    }
    case XIPFS_USER_SYSCALL_MEMSET: {
        void *m = (void *)svc_args[1];
        int c = (int)svc_args[2];
        size_t n = (size_t)svc_args[3];
        xipfs_user_syscall_memset_t f = (xipfs_user_syscall_memset_t)
            crt0_ctx->user_syscall_table[XIPFS_USER_SYSCALL_MEMSET];
        crt0_ctx->syscall_result = (uintptr_t)f(m, c, n);
        break;
    }
    default:
        break;
    }
}

#endif /* XIPFS_ENABLE_SAFE_EXEC_SUPPORT */
